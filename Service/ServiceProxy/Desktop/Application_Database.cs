//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Tool name: CGW X-Script Linq to SQL Layer Generator
//
//     Archymeta Information Technologies Co., Ltd.
//
//     Changes to this file, especially those bit flags, may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Configuration;
using System.Data.Linq;
using System.Data.Linq.Mapping;
using System.Data;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Reflection;
using System.Linq;
using System.Linq.Expressions;
using System.ComponentModel;
using System.ServiceModel;
using System.ServiceModel.Channels;

namespace CryptoGateway.RDB.Data.MembershipPlus
{
    /// <summary>
    /// Proxy for <see cref="IApplication_Service2" /> service.
    /// </summary>
    /// <remarks>
    ///  <para>
    ///    Methods of the service are categorized in the following:
    ///  </para>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Adding, Updating or Removing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Adding, updating or removing entity graphs to or from data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="Application_ServiceProxy.AddOrUpdateEntities" />, <see cref="Application_ServiceProxy.EnqueueNewOrUpdateEntities" />, and <see cref="Application_ServiceProxy.DeleteEntities" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Paged Listing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides paged listing of query results.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="Application_ServiceProxy.NextPageBlock" /> and <see cref="Application_ServiceProxy.GetPageItems" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Query the data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="Application_ServiceProxy.QueryEntityCount" />, <see cref="Application_ServiceProxy.QueryDatabase" />, <see cref="Application_ServiceProxy.QueryDatabaseLimited" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity Lookup</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Find an entity from the corresponding entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="Application_ServiceProxy.LoadEntityByKey" /> and <see cref="Application_ServiceProxy.LoadEntityByNature" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying Intelligency</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides a self-complete system for clients to construct query expressions. What completeness means here is that all options are included and 
    ///      no extra (to the query system) options are present.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="Application_ServiceProxy.GetNextSorterOps" /> and <see cref="Application_ServiceProxy.GetNextFilterOps" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Downstream Navigation</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load and/or navigates to entity sets that depend on an entity in the current entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="Application_ServiceProxy.MaterializeAnnouncements" />, <see cref="Application_ServiceProxy.MaterializeCommunications" />, <see cref="Application_ServiceProxy.MaterializeEventCalendars" />, <see cref="Application_ServiceProxy.MaterializeRoles" />, <see cref="Application_ServiceProxy.MaterializeUserAppMembers" />, <see cref="Application_ServiceProxy.MaterializeUserDetails" />, <see cref="Application_ServiceProxy.MaterializeUserProfiles" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity graph building</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load a selected entity graph from the data source starting at an entity having specified primary key(s)
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="Application_ServiceProxy.LoadEntityGraphRecurs" />.
    ///      </description>
    ///    </item>
    ///  </list>
    /// </remarks>
    public class Application_ServiceProxy : ClientBase<IApplication_Service2>, IApplication_Service2
    {
        /// <summary>
        /// Constructor.
        /// </summary>
        public Application_ServiceProxy() 
            : base("HTTP")
        {

        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="svcConfig">The name of the configuration node for the end point.</param>
        public Application_ServiceProxy(string svcConfig) 
            : base(svcConfig)
        {

        }

        /// <summary>
        /// Initializes a new instance using the specified binding and target address. 
        /// </summary>
        /// <param name="binding">The binding with which to make calls to the service.</param>
        /// <param name="remoteAddress">The address of the service endpoint.</param>
        public Application_ServiceProxy(Binding binding, EndpointAddress remoteAddress)
            : base(binding, remoteAddress)
        {

        }

        public Action<Exception> DelHandleError = null;
        /// <summary>
        ///   Retrieve information about the entity set: "Applications". 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="Application_Set" /> data model.
        /// </returns>
        public Application_Set GetSetInfo(CallContext cntx, string filter)
        {
            try
            {
                return Channel.GetSetInfo(cntx, filter);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Retrieve information about the entity set: "Applications". Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="Application_Set" /> data model.
        /// </returns>
        public async System.Threading.Tasks.Task<Application_Set> GetSetInfoAsync(CallContext cntx, string filter)
        {
            try
            {
                return await Channel.GetSetInfoAsync(cntx, filter);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Add or update a set of entities to the entity set. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Application_" />) is modified or its <see cref="Application_.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="Application_.ChangedAnnouncements" />, <see cref="Application_.ChangedCommunications" />, <see cref="Application_.ChangedEventCalendars" />, <see cref="Application_.ChangedRoles" />, <see cref="Application_.ChangedUserAppMembers" />, <see cref="Application_.ChangedUserDetails" />, <see cref="Application_.ChangedUserProfiles" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        public ChangeOpResults<Application_UpdateResult> AddOrUpdateEntities(CallContext cntx, Application_Set set, Application_[] entities)
        {
            try
            {
                return Channel.AddOrUpdateEntities(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Add or update a set of entities to the entity set. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Application_" />) is modified or its <see cref="Application_.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="Application_.ChangedAnnouncements" />, <see cref="Application_.ChangedCommunications" />, <see cref="Application_.ChangedEventCalendars" />, <see cref="Application_.ChangedRoles" />, <see cref="Application_.ChangedUserAppMembers" />, <see cref="Application_.ChangedUserDetails" />, <see cref="Application_.ChangedUserProfiles" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        public async System.Threading.Tasks.Task<ChangeOpResults<Application_UpdateResult>> AddOrUpdateEntitiesAsync(CallContext cntx, Application_Set set, Application_[] entities)
        {
            try
            {
                return await Channel.AddOrUpdateEntitiesAsync(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Application_" />) is modified or its <see cref="Application_.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="Application_.ChangedAnnouncements" />, <see cref="Application_.ChangedCommunications" />, <see cref="Application_.ChangedEventCalendars" />, <see cref="Application_.ChangedRoles" />, <see cref="Application_.ChangedUserAppMembers" />, <see cref="Application_.ChangedUserDetails" />, <see cref="Application_.ChangedUserProfiles" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        public void EnqueueNewOrUpdateEntities(CallContext cntx, Application_Set set, Application_[] entities)
        {
            try
            {
                Channel.EnqueueNewOrUpdateEntities(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Application_" />) is modified or its <see cref="Application_.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="Application_.ChangedAnnouncements" />, <see cref="Application_.ChangedCommunications" />, <see cref="Application_.ChangedEventCalendars" />, <see cref="Application_.ChangedRoles" />, <see cref="Application_.ChangedUserAppMembers" />, <see cref="Application_.ChangedUserDetails" />, <see cref="Application_.ChangedUserProfiles" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        public async System.Threading.Tasks.Task EnqueueNewOrUpdateEntitiesAsync(CallContext cntx, Application_Set set, Application_[] entities)
        {
            try
            {
                await Channel.EnqueueNewOrUpdateEntitiesAsync(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
            }
        }
#endif

        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        public OperationResults DeleteEntities(CallContext cntx, Application_Set set, Application_[] entities)
        {
            try
            {
                return Channel.DeleteEntities(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        public async System.Threading.Tasks.Task<OperationResults> DeleteEntitiesAsync(CallContext cntx, Application_Set set, Application_[] entities)
        {
            try
            {
                return await Channel.DeleteEntitiesAsync(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Get a block of page frames from the entity set "Applications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="Application_PageBlock" /> data model for entity set "Applications".
        /// </returns>
        public Application_PageBlock NextPageBlock(CallContext cntx, Application_Set set, QueryExpresion qexpr, Application_ prevlast)
        {
            try
            {
                if (prevlast != null)
                   prevlast  = prevlast.ShallowCopy();
                return Channel.NextPageBlock(cntx, set, qexpr, prevlast);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC

        /// <summary>
        ///   Get a block of page frames from the entity set "Applications" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="Application_PageBlock" /> data model for entity set "Applications".
        /// </returns>
        public async System.Threading.Tasks.Task<Application_PageBlock> NextPageBlockAsync(CallContext cntx, Application_Set set, QueryExpresion qexpr, Application_ prevlast)
        {
            try
            {
                if (prevlast != null)
                   prevlast  = prevlast.ShallowCopy();
                return await Channel.NextPageBlockAsync(cntx, set, qexpr, prevlast);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load entities of a page from the entity set "Applications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="Application_" /> in set "Applications" for the current page defined by "prevlast".
        /// </returns>
        public IEnumerable<Application_> GetPageItems(CallContext cntx, Application_Set set, QueryExpresion qexpr, Application_ prevlast)
        {
            try
            {
                if (prevlast != null)
                   prevlast  = prevlast.ShallowCopy();
                return Channel.GetPageItems(cntx, set, qexpr, prevlast);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC

        /// <summary>
        ///   Load entities of a page from the entity set "Applications" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="Application_" /> in set "Applications" for the current page defined by "prevlast".
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<Application_>> GetPageItemsAsync(CallContext cntx, Application_Set set, QueryExpresion qexpr, Application_ prevlast)
        {
            try
            {
                if (prevlast != null)
                   prevlast  = prevlast.ShallowCopy();
                return await Channel.GetPageItemsAsync(cntx, set, qexpr, prevlast);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Count the number of entities inside entity set "Applications" of the data source under specified filtering condition. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        public Int64 QueryEntityCount(CallContext cntx, Application_Set set, QueryExpresion qexpr)
        {
            try
            {
                return Channel.QueryEntityCount(cntx, set, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return default(Int64);
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Count the number of entities inside entity set "Applications" of the data source under specified filtering condition. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        public async System.Threading.Tasks.Task<Int64> QueryEntityCountAsync(CallContext cntx, Application_Set set, QueryExpresion qexpr)
        {
            try
            {
                return await Channel.QueryEntityCountAsync(cntx, set, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return default(Int64);
            }
        }
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="Application_" /> inside entity set "Applications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public IEnumerable<Application_> QueryDatabase(CallContext cntx, Application_Set set, QueryExpresion qexpr)
        {
            try
            {
                return Channel.QueryDatabase(cntx, set, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="Application_" /> inside entity set "Applications" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<Application_>> QueryDatabaseAsync(CallContext cntx, Application_Set set, QueryExpresion qexpr)
        {
            try
            {
                return await Channel.QueryDatabaseAsync(cntx, set, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="Application_" /> inside entity set "Applications" from the data source under specified filtering, sorting and max number of returning entities conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public IEnumerable<Application_> QueryDatabaseLimited(CallContext cntx, Application_Set set, QueryExpresion qexpr, int maxRecords)
        {
            try
            {
                return Channel.QueryDatabaseLimited(cntx, set, qexpr, maxRecords);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="Application_" /> inside entity set "Applications" from the data source under specified filtering, sorting and max number of returning entities conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<Application_>> QueryDatabaseLimitedAsync(CallContext cntx, Application_Set set, QueryExpresion qexpr, int maxRecords)
        {
            try
            {
                return await Channel.QueryDatabaseLimitedAsync(cntx, set, qexpr, maxRecords);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "Announcements" of type <see cref="AnnouncementSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="AnnouncementSet" />.
        /// </returns>
        public AnnouncementSet MaterializeAnnouncements(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeAnnouncements(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "Announcements" of type <see cref="AnnouncementSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="AnnouncementSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<AnnouncementSet> MaterializeAnnouncementsAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeAnnouncementsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllAnnouncements" of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />).
        /// </returns>
        public IEnumerable<Announcement> MaterializeAllAnnouncements(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeAllAnnouncements(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllAnnouncements" of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<Announcement>> MaterializeAllAnnouncementsAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeAllAnnouncementsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "Communications" of type <see cref="CommunicationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="CommunicationSet" />.
        /// </returns>
        public CommunicationSet MaterializeCommunications(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeCommunications(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "Communications" of type <see cref="CommunicationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="CommunicationSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<CommunicationSet> MaterializeCommunicationsAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeCommunicationsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllCommunications" of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />).
        /// </returns>
        public IEnumerable<Communication> MaterializeAllCommunications(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeAllCommunications(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllCommunications" of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<Communication>> MaterializeAllCommunicationsAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeAllCommunicationsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "EventCalendars" of type <see cref="EventCalendarSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        public EventCalendarSet MaterializeEventCalendars(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeEventCalendars(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "EventCalendars" of type <see cref="EventCalendarSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<EventCalendarSet> MaterializeEventCalendarsAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeEventCalendarsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendars" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        public IEnumerable<EventCalendar> MaterializeAllEventCalendars(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeAllEventCalendars(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendars" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<EventCalendar>> MaterializeAllEventCalendarsAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeAllEventCalendarsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "Roles" of type <see cref="RoleSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="RoleSet" />.
        /// </returns>
        public RoleSet MaterializeRoles(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeRoles(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "Roles" of type <see cref="RoleSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="RoleSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<RoleSet> MaterializeRolesAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeRolesAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllRoles" of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />).
        /// </returns>
        public IEnumerable<Role> MaterializeAllRoles(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeAllRoles(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllRoles" of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<Role>> MaterializeAllRolesAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeAllRolesAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UserAppMembers" of type <see cref="UserAppMemberSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAppMemberSet" />.
        /// </returns>
        public UserAppMemberSet MaterializeUserAppMembers(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeUserAppMembers(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserAppMembers" of type <see cref="UserAppMemberSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAppMemberSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserAppMemberSet> MaterializeUserAppMembersAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeUserAppMembersAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserAppMembers" of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />).
        /// </returns>
        public IEnumerable<UserAppMember> MaterializeAllUserAppMembers(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeAllUserAppMembers(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserAppMembers" of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UserAppMember>> MaterializeAllUserAppMembersAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeAllUserAppMembersAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of indirectly depending entities "UserAppMember" of type <see cref="UserSet" /> of an entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        public UserSet MaterializeAppUsers(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeAppUsers(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of indirectly depending entities "UserAppMember" of type <see cref="UserSet" /> of an entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserSet> MaterializeAppUsersAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeAppUsersAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of indirectly depending entities "AllAppUsers" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        public IEnumerable<User> MaterializeAllAppUsers(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeAllAppUsers(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of indirectly depending entities "AllAppUsers" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<User>> MaterializeAllAppUsersAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeAllAppUsersAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UserDetails" of type <see cref="UserDetailSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserDetailSet" />.
        /// </returns>
        public UserDetailSet MaterializeUserDetails(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeUserDetails(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserDetails" of type <see cref="UserDetailSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserDetailSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserDetailSet> MaterializeUserDetailsAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeUserDetailsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserDetails" of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />).
        /// </returns>
        public IEnumerable<UserDetail> MaterializeAllUserDetails(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeAllUserDetails(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserDetails" of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UserDetail>> MaterializeAllUserDetailsAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeAllUserDetailsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UserProfiles" of type <see cref="UserProfileSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserProfileSet" />.
        /// </returns>
        public UserProfileSet MaterializeUserProfiles(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeUserProfiles(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserProfiles" of type <see cref="UserProfileSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserProfileSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserProfileSet> MaterializeUserProfilesAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeUserProfilesAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserProfiles" of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />).
        /// </returns>
        public IEnumerable<UserProfile> MaterializeAllUserProfiles(CallContext cntx, Application_ entity)
        {
            try
            {
                return Channel.MaterializeAllUserProfiles(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserProfiles" of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UserProfile>> MaterializeAllUserProfilesAsync(CallContext cntx, Application_ entity)
        {
            try
            {
                return await Channel.MaterializeAllUserProfilesAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="Application_.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Application_.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        public Application_ LoadEntityByKey(CallContext cntx, string _ID)
        {
            try
            {
                return Channel.LoadEntityByKey(cntx, _ID);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="Application_.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Application_.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        public async System.Threading.Tasks.Task<Application_> LoadEntityByKeyAsync(CallContext cntx, string _ID)
        {
            try
            {
                return await Channel.LoadEntityByKeyAsync(cntx, _ID);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="Application_.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Application_.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively starting from a given entity (id) from the data source in one call 
        /// to the service, which could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by the two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also load all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that does not allow transimitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        public Application_ LoadEntityGraphRecurs(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets)
        {
            try
            {
                return Channel.LoadEntityGraphRecurs(cntx, _ID, excludedSets, futherDrillSets);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="Application_.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Application_.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively starting from a given entity (id) from the data source in one call 
        /// to the service, which could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by the two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also load all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that does not allow transimitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        public async System.Threading.Tasks.Task<Application_> LoadEntityGraphRecursAsync(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets)
        {
            try
            {
                return await Channel.LoadEntityGraphRecursAsync(cntx, _ID, excludedSets, futherDrillSets);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="Application_.Name" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_Name">Intrinsic id <see cref="Application_.Name" />.</param>
        /// <remarks>
        ///  <para>
        ///   If the intrinsic identifiers are well chosen, the returned entity set should contain zero or one item. This could not be the case
        ///   if the system is attached to an existing database whose data were entered without respecting the rules (namely those entities having the
        ///   same set of intrinsic identifiers should appear only once inside the data source) imposed later by the
        ///   system.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   The list of found entities.
        /// </returns>
        public List<Application_> LoadEntityByNature(CallContext cntx, string _Name)
        {
            try
            {
                return Channel.LoadEntityByNature(cntx, _Name);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="Application_.Name" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_Name">Intrinsic id <see cref="Application_.Name" />.</param>
        /// <remarks>
        ///  <para>
        ///   If the intrinsic identifiers are well chosen, the returned entity set should contain zero or one item. This could not be the case
        ///   if the system is attached to an existing database whose data were entered without respecting the rules (namely those entities having the
        ///   same set of intrinsic identifiers should appear only once inside the data source) imposed later by the
        ///   system.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   The list of found entities.
        /// </returns>
        public async System.Threading.Tasks.Task<List<Application_>> LoadEntityByNatureAsync(CallContext cntx, string _Name)
        {
            try
            {
                return await Channel.LoadEntityByNatureAsync(cntx, _Name);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        public TokenOptions GetNextSorterOps(CallContext cntx, List<QToken> sorters)
        {
            try
            {
                return Channel.GetNextSorterOps(cntx, sorters);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        public async System.Threading.Tasks.Task<TokenOptions> GetNextSorterOpsAsync(CallContext cntx, List<QToken> sorters)
        {
            try
            {
                return await Channel.GetNextSorterOpsAsync(cntx, sorters);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        public TokenOptions GetNextFilterOps(CallContext cntx, QueryExpresion qexpr, string tkstr)
        {
            try
            {
                return Channel.GetNextFilterOps(cntx, qexpr, tkstr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        public async System.Threading.Tasks.Task<TokenOptions> GetNextFilterOpsAsync(CallContext cntx, QueryExpresion qexpr, string tkstr)
        {
            try
            {
                return await Channel.GetNextFilterOpsAsync(cntx, qexpr, tkstr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        private void HandleError(Exception ex)
        {
            if (DelHandleError != null)
                DelHandleError(ex);
            else
                throw new Exception("server exception", ex);
        }
    }
}