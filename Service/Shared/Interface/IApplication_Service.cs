//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool from CryptoGateway Software Inc.
//     Tool name: CGW X-Script RDB visual Layer Generator
//
//     Archymeta Information Technologies Co., Ltd.
//
//     Changes to this file, could be overwritten if the code is re-generated.
//     Add (if not yet) a code-manager node to the generator to specify 
//     how existing files are processed.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Configuration;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;

namespace CryptoGateway.RDB.Data.MembershipPlus
{
    /// <summary>
    /// It is bound to webHttp end points accessed by javascript using json serialization method.
    /// </summary>
    /// <remarks>
    ///  <para>
    ///    Methods of the service are categorized in the following:
    ///  </para>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Adding, Updating or Removing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Adding, updating or removing entity graphs to or from data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IApplication_Service.AddOrUpdateEntities" />, <see cref="IApplication_Service.EnqueueNewOrUpdateEntities" />, and <see cref="IApplication_Service.DeleteEntities" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Paged Listing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides paged listing of query results.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IApplication_Service.NextPageBlock" /> and <see cref="IApplication_Service.GetPageItems" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Query the data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IApplication_Service.QueryEntityCount" />, <see cref="IApplication_Service.QueryDatabase" />, <see cref="IApplication_Service.QueryDatabaseLimited" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity Lookup</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Find an entity from the corresponding entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IApplication_Service.LoadEntityByKey" /> and <see cref="IApplication_Service.LoadEntityByNature" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying Intelligency</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides a self-complete system for clients to construct query expressions. What completeness means here is that all options are included and 
    ///      no extra (to the query system) options are present.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IApplication_Service.GetNextSorterOps" /> and <see cref="IApplication_Service.GetNextFilterOps" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Downstream Navigation</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load and/or navigates to entity sets that depend on an entity in the current entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="IApplication_Service.MaterializeAnnouncements" />, <see cref="IApplication_Service.MaterializeCommunications" />, <see cref="IApplication_Service.MaterializeEventCalendars" />, <see cref="IApplication_Service.MaterializeMemberNotifications" />, <see cref="IApplication_Service.MaterializeRoles" />, <see cref="IApplication_Service.MaterializeSignalRHostStates" />, <see cref="IApplication_Service.MaterializeSignalRMessages" />, <see cref="IApplication_Service.MaterializeUserAppMembers" />, <see cref="IApplication_Service.MaterializeUserDetails" />, <see cref="IApplication_Service.MaterializeUserGroups" />, <see cref="IApplication_Service.MaterializeUserProfiles" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity graph building</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load a selected entity graph from the data source starting at an entity having specified primary key(s)
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="IApplication_Service.LoadEntityGraphRecurs" />.
    ///      </description>
    ///    </item>
    ///  </list>
    /// </remarks>
    [ServiceContract(Namespace = "http://relationaldb.archymeta.com/MembershipPlus/", SessionMode = SessionMode.Allowed)]
    public interface IApplication_Service
    {
        /// <summary>
        ///   Retrieve information about the entity set: "Applications". 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="Application_Set" /> data model.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/GetSetInfo")]
        Application_Set GetSetInfo(CallContext cntx, string filter);

        /// <summary>
        ///   Get a block of page frames from the entity set "Applications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="Application_PageBlock" /> data model for entity set "Applications".
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/NextPageBlock")]
        Application_PageBlock NextPageBlock(CallContext cntx, Application_Set set, QueryExpresion qexpr, Application_ prevlast);

        /// <summary>
        ///   Load entities of a page from the entity set "Applications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="Application_" /> in set "Applications" for the current page defined by "prevlast".
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/GetPageItems")]
        IEnumerable<Application_> GetPageItems(CallContext cntx, Application_Set set, QueryExpresion qexpr, Application_ prevlast);

        /// <summary>
        ///   Add or update a set of entities to the entity set. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Application_" />) is modified or its <see cref="Application_.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="Application_.ChangedAnnouncements" />, <see cref="Application_.ChangedCommunications" />, <see cref="Application_.ChangedEventCalendars" />, <see cref="Application_.ChangedMemberNotifications" />, <see cref="Application_.ChangedRoles" />, <see cref="Application_.ChangedSignalRHostStates" />, <see cref="Application_.ChangedSignalRMessages" />, <see cref="Application_.ChangedUserAppMembers" />, <see cref="Application_.ChangedUserDetails" />, <see cref="Application_.ChangedUserGroups" />, <see cref="Application_.ChangedUserProfiles" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/AddOrUpdateEntities")]
        ChangeOpResults<Application_UpdateResult> AddOrUpdateEntities(CallContext cntx, Application_Set set, Application_[] entities);

        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Application_" />) is modified or its <see cref="Application_.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="Application_.ChangedAnnouncements" />, <see cref="Application_.ChangedCommunications" />, <see cref="Application_.ChangedEventCalendars" />, <see cref="Application_.ChangedMemberNotifications" />, <see cref="Application_.ChangedRoles" />, <see cref="Application_.ChangedSignalRHostStates" />, <see cref="Application_.ChangedSignalRMessages" />, <see cref="Application_.ChangedUserAppMembers" />, <see cref="Application_.ChangedUserDetails" />, <see cref="Application_.ChangedUserGroups" />, <see cref="Application_.ChangedUserProfiles" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/EnqueueNewOrUpdateEntities")]
        void EnqueueNewOrUpdateEntities(CallContext cntx, Application_Set set, Application_[] entities);

        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/DeleteEntities")]
        OperationResults DeleteEntities(CallContext cntx, Application_Set set, Application_[] entities);

        /// <summary>
        ///   Count the number of entities inside entity set "Applications" of the data source under specified filtering condition. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/QueryEntityCount")]
        Int64 QueryEntityCount(CallContext cntx, Application_Set set, QueryExpresion qexpr);

        /// <summary>
        ///   Get the collection of entities of type <see cref="Application_" /> inside entity set "Applications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/QueryDatabase")]
        IEnumerable<Application_> QueryDatabase(CallContext cntx, Application_Set set, QueryExpresion qexpr);

        /// <summary>
        ///   Get the collection of entities of type <see cref="Application_" /> inside entity set "Applications" from the data source under specified filtering, sorting and max number of returning entities conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/QueryDatabaseLimited")]
        IEnumerable<Application_> QueryDatabaseLimited(CallContext cntx, Application_Set set, QueryExpresion qexpr, int maxRecords);

        /// <summary>
        ///   Load the set of depending entities "Announcements" of type <see cref="AnnouncementSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="AnnouncementSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAnnouncements")]
        AnnouncementSet MaterializeAnnouncements(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the collection of depending entities "AllAnnouncements" of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllAnnouncements")]
        IEnumerable<Announcement> MaterializeAllAnnouncements(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the set of depending entities "Communications" of type <see cref="CommunicationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="CommunicationSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeCommunications")]
        CommunicationSet MaterializeCommunications(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the collection of depending entities "AllCommunications" of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllCommunications")]
        IEnumerable<Communication> MaterializeAllCommunications(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the set of depending entities "EventCalendars" of type <see cref="EventCalendarSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeEventCalendars")]
        EventCalendarSet MaterializeEventCalendars(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendars" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllEventCalendars")]
        IEnumerable<EventCalendar> MaterializeAllEventCalendars(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the set of depending entities "MemberNotifications" of type <see cref="MemberNotificationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="MemberNotificationSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeMemberNotifications")]
        MemberNotificationSet MaterializeMemberNotifications(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the collection of depending entities "AllMemberNotifications" of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllMemberNotifications")]
        IEnumerable<MemberNotification> MaterializeAllMemberNotifications(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the set of depending entities "Roles" of type <see cref="RoleSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="RoleSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeRoles")]
        RoleSet MaterializeRoles(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the collection of depending entities "AllRoles" of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllRoles")]
        IEnumerable<Role> MaterializeAllRoles(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the set of depending entities "SignalRHostStates" of type <see cref="SignalRHostStateSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="SignalRHostStateSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeSignalRHostStates")]
        SignalRHostStateSet MaterializeSignalRHostStates(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the collection of depending entities "AllSignalRHostStates" of type <see cref="IEnumerable{SignalRHostState}" /> (T = <see cref="SignalRHostState" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{SignalRHostState}" /> (T = <see cref="SignalRHostState" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllSignalRHostStates")]
        IEnumerable<SignalRHostState> MaterializeAllSignalRHostStates(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the set of depending entities "SignalRMessages" of type <see cref="SignalRMessageSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="SignalRMessageSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeSignalRMessages")]
        SignalRMessageSet MaterializeSignalRMessages(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the collection of depending entities "AllSignalRMessages" of type <see cref="IEnumerable{SignalRMessage}" /> (T = <see cref="SignalRMessage" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{SignalRMessage}" /> (T = <see cref="SignalRMessage" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllSignalRMessages")]
        IEnumerable<SignalRMessage> MaterializeAllSignalRMessages(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the set of depending entities "UserAppMembers" of type <see cref="UserAppMemberSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAppMemberSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUserAppMembers")]
        UserAppMemberSet MaterializeUserAppMembers(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUserAppMembers" of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUserAppMembers")]
        IEnumerable<UserAppMember> MaterializeAllUserAppMembers(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the set of indirectly depending entities "AppUserss" of type <see cref="UserSet" /> of an entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAppUsers")]
        UserSet MaterializeAppUsers(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the collection of indirectly depending entities "AllAppUserss" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllAppUsers")]
        IEnumerable<User> MaterializeAllAppUsers(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the set of depending entities "UserDetails" of type <see cref="UserDetailSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserDetailSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUserDetails")]
        UserDetailSet MaterializeUserDetails(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUserDetails" of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUserDetails")]
        IEnumerable<UserDetail> MaterializeAllUserDetails(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the set of depending entities "UserGroups" of type <see cref="UserGroupSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserGroupSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUserGroups")]
        UserGroupSet MaterializeUserGroups(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUserGroups" of type <see cref="IEnumerable{UserGroup}" /> (T = <see cref="UserGroup" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserGroup}" /> (T = <see cref="UserGroup" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUserGroups")]
        IEnumerable<UserGroup> MaterializeAllUserGroups(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the set of depending entities "UserProfiles" of type <see cref="UserProfileSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserProfileSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUserProfiles")]
        UserProfileSet MaterializeUserProfiles(CallContext cntx, Application_ entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUserProfiles" of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUserProfiles")]
        IEnumerable<UserProfile> MaterializeAllUserProfiles(CallContext cntx, Application_ entity);

        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="Application_.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Application_.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/LoadEntityByKey")]
        Application_ LoadEntityByKey(CallContext cntx, string _ID);

        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="Application_.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Application_.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
        /// It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/LoadEntityGraphRecurs")]
        Application_ LoadEntityGraphRecurs(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets);

        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="Application_.Name" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_Name">Intrinsic id <see cref="Application_.Name" />.</param>
        /// <remarks>
        ///  <para>
        ///   If the intrinsic identifiers are well chosen, the returned entity set should contain zero or one item. This could not be the case
        ///   if the system is attached to an existing database whose data were entered without respecting the rules (namely those entities having the
        ///   same set of intrinsic identifiers should appear only once inside the data source) imposed later by the
        ///   system.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   The list of found entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/LoadEntityByNature")]
        List<Application_> LoadEntityByNature(CallContext cntx, string _Name);

        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/GetNextSorterOps")]
        TokenOptions GetNextSorterOps(CallContext cntx, List<QToken> sorters);

        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/GetNextFilterOps")]
        TokenOptions GetNextFilterOps(CallContext cntx, QueryExpresion qexpr, string tkstr);

    }

    /// <summary>
    /// It is bound to basicHttp end points accessed by clients other than a web browser.
    /// </summary>
    /// <remarks>
    ///  <para>
    ///    Methods of the service are categorized in the following:
    ///  </para>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Adding, Updating or Removing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Adding, updating or removing entity graphs to or from data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IApplication_Service2.AddOrUpdateEntities" />, <see cref="IApplication_Service2.EnqueueNewOrUpdateEntities" />, and <see cref="IApplication_Service2.DeleteEntities" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Paged Listing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides paged listing of query results.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IApplication_Service2.NextPageBlock" /> and <see cref="IApplication_Service2.GetPageItems" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Query the data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IApplication_Service2.QueryEntityCount" />, <see cref="IApplication_Service2.QueryDatabase" />, <see cref="IApplication_Service2.QueryDatabaseLimited" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity Lookup</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Find an entity from the corresponding entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IApplication_Service2.LoadEntityByKey" /> and <see cref="IApplication_Service2.LoadEntityByNature" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying Intelligency</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides a self-complete system for clients to construct query expressions. What completeness means here is that all options are included and 
    ///      no extra (to the query system) options are present.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IApplication_Service2.GetNextSorterOps" /> and <see cref="IApplication_Service2.GetNextFilterOps" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Downstream Navigation</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load and/or navigates to entity sets that depend on an entity in the current entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="IApplication_Service2.MaterializeAnnouncements" />, <see cref="IApplication_Service2.MaterializeCommunications" />, <see cref="IApplication_Service2.MaterializeEventCalendars" />, <see cref="IApplication_Service2.MaterializeMemberNotifications" />, <see cref="IApplication_Service2.MaterializeRoles" />, <see cref="IApplication_Service2.MaterializeSignalRHostStates" />, <see cref="IApplication_Service2.MaterializeSignalRMessages" />, <see cref="IApplication_Service2.MaterializeUserAppMembers" />, <see cref="IApplication_Service2.MaterializeUserDetails" />, <see cref="IApplication_Service2.MaterializeUserGroups" />, <see cref="IApplication_Service2.MaterializeUserProfiles" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity graph building</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load a selected entity graph from the data source starting at an entity having specified primary key(s)
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="IApplication_Service2.LoadEntityGraphRecurs" />.
    ///      </description>
    ///    </item>
    ///  </list>
    /// </remarks>
    [ServiceContract(Namespace = "http://relationaldb.archymeta.com/MembershipPlus/", SessionMode = SessionMode.Allowed)]
    public interface IApplication_Service2
    {
        /// <summary>
        ///   Retrieve information about the entity set: "Applications". 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="Application_Set" /> data model.
        /// </returns>
        [OperationContract]
        Application_Set GetSetInfo(CallContext cntx, string filter);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Retrieve information about the entity set: "Applications". Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="Application_Set" /> data model.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<Application_Set> GetSetInfoAsync(CallContext cntx, string filter);
#endif

        /// <summary>
        ///   Get a block of page frames from the entity set "Applications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="Application_PageBlock" /> data model for entity set "Applications".
        /// </returns>
        [OperationContract]
        Application_PageBlock NextPageBlock(CallContext cntx, Application_Set set, QueryExpresion qexpr, Application_ prevlast);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Get a block of page frames from the entity set "Applications" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="Application_PageBlock" /> data model for entity set "Applications".
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<Application_PageBlock> NextPageBlockAsync(CallContext cntx, Application_Set set, QueryExpresion qexpr, Application_ prevlast);
#endif

        /// <summary>
        ///   Load entities of a page from the entity set "Applications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="Application_" /> in set "Applications" for the current page defined by "prevlast".
        /// </returns>
        [OperationContract]
        IEnumerable<Application_> GetPageItems(CallContext cntx, Application_Set set, QueryExpresion qexpr, Application_ prevlast);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load entities of a page from the entity set "Applications" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="Application_" /> in set "Applications" for the current page defined by "prevlast".
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Application_>> GetPageItemsAsync(CallContext cntx, Application_Set set, QueryExpresion qexpr, Application_ prevlast);
#endif

        /// <summary>
        ///   Add or update a set of entities to the entity set. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Application_" />) is modified or its <see cref="Application_.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="Application_.ChangedAnnouncements" />, <see cref="Application_.ChangedCommunications" />, <see cref="Application_.ChangedEventCalendars" />, <see cref="Application_.ChangedMemberNotifications" />, <see cref="Application_.ChangedRoles" />, <see cref="Application_.ChangedSignalRHostStates" />, <see cref="Application_.ChangedSignalRMessages" />, <see cref="Application_.ChangedUserAppMembers" />, <see cref="Application_.ChangedUserDetails" />, <see cref="Application_.ChangedUserGroups" />, <see cref="Application_.ChangedUserProfiles" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        [OperationContract]
        ChangeOpResults<Application_UpdateResult> AddOrUpdateEntities(CallContext cntx, Application_Set set, Application_[] entities);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Add or update a set of entities to the entity set. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Application_" />) is modified or its <see cref="Application_.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="Application_.ChangedAnnouncements" />, <see cref="Application_.ChangedCommunications" />, <see cref="Application_.ChangedEventCalendars" />, <see cref="Application_.ChangedMemberNotifications" />, <see cref="Application_.ChangedRoles" />, <see cref="Application_.ChangedSignalRHostStates" />, <see cref="Application_.ChangedSignalRMessages" />, <see cref="Application_.ChangedUserAppMembers" />, <see cref="Application_.ChangedUserDetails" />, <see cref="Application_.ChangedUserGroups" />, <see cref="Application_.ChangedUserProfiles" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<ChangeOpResults<Application_UpdateResult>> AddOrUpdateEntitiesAsync(CallContext cntx, Application_Set set, Application_[] entities);
#endif

        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Application_" />) is modified or its <see cref="Application_.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="Application_.ChangedAnnouncements" />, <see cref="Application_.ChangedCommunications" />, <see cref="Application_.ChangedEventCalendars" />, <see cref="Application_.ChangedMemberNotifications" />, <see cref="Application_.ChangedRoles" />, <see cref="Application_.ChangedSignalRHostStates" />, <see cref="Application_.ChangedSignalRMessages" />, <see cref="Application_.ChangedUserAppMembers" />, <see cref="Application_.ChangedUserDetails" />, <see cref="Application_.ChangedUserGroups" />, <see cref="Application_.ChangedUserProfiles" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        [OperationContract]
        void EnqueueNewOrUpdateEntities(CallContext cntx, Application_Set set, Application_[] entities);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Application_" />) is modified or its <see cref="Application_.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="Application_.ChangedAnnouncements" />, <see cref="Application_.ChangedCommunications" />, <see cref="Application_.ChangedEventCalendars" />, <see cref="Application_.ChangedMemberNotifications" />, <see cref="Application_.ChangedRoles" />, <see cref="Application_.ChangedSignalRHostStates" />, <see cref="Application_.ChangedSignalRMessages" />, <see cref="Application_.ChangedUserAppMembers" />, <see cref="Application_.ChangedUserDetails" />, <see cref="Application_.ChangedUserGroups" />, <see cref="Application_.ChangedUserProfiles" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task EnqueueNewOrUpdateEntitiesAsync(CallContext cntx, Application_Set set, Application_[] entities);
#endif

        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        [OperationContract]
        OperationResults DeleteEntities(CallContext cntx, Application_Set set, Application_[] entities);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<OperationResults> DeleteEntitiesAsync(CallContext cntx, Application_Set set, Application_[] entities);
#endif

        /// <summary>
        ///   Count the number of entities inside entity set "Applications" of the data source under specified filtering condition. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        [OperationContract]
        Int64 QueryEntityCount(CallContext cntx, Application_Set set, QueryExpresion qexpr);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Count the number of entities inside entity set "Applications" of the data source under specified filtering condition. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<Int64> QueryEntityCountAsync(CallContext cntx, Application_Set set, QueryExpresion qexpr);
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="Application_" /> inside entity set "Applications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        IEnumerable<Application_> QueryDatabase(CallContext cntx, Application_Set set, QueryExpresion qexpr);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="Application_" /> inside entity set "Applications" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Application_>> QueryDatabaseAsync(CallContext cntx, Application_Set set, QueryExpresion qexpr);
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="Application_" /> inside entity set "Applications" from the data source under specified filtering, sorting and max number of returning entities conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        IEnumerable<Application_> QueryDatabaseLimited(CallContext cntx, Application_Set set, QueryExpresion qexpr, int maxRecords);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="Application_" /> inside entity set "Applications" from the data source under specified filtering, sorting and max number of returning entities conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Application_>> QueryDatabaseLimitedAsync(CallContext cntx, Application_Set set, QueryExpresion qexpr, int maxRecords);
#endif

        /// <summary>
        ///   Load the set of depending entities "Announcements" of type <see cref="AnnouncementSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="AnnouncementSet" />.
        /// </returns>
        [OperationContract]
        AnnouncementSet MaterializeAnnouncements(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "Announcements" of type <see cref="AnnouncementSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="AnnouncementSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<AnnouncementSet> MaterializeAnnouncementsAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllAnnouncements" of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />).
        /// </returns>
        [OperationContract]
        IEnumerable<Announcement> MaterializeAllAnnouncements(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllAnnouncements" of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Announcement>> MaterializeAllAnnouncementsAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "Communications" of type <see cref="CommunicationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="CommunicationSet" />.
        /// </returns>
        [OperationContract]
        CommunicationSet MaterializeCommunications(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "Communications" of type <see cref="CommunicationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="CommunicationSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<CommunicationSet> MaterializeCommunicationsAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllCommunications" of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />).
        /// </returns>
        [OperationContract]
        IEnumerable<Communication> MaterializeAllCommunications(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllCommunications" of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Communication>> MaterializeAllCommunicationsAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "EventCalendars" of type <see cref="EventCalendarSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        [OperationContract]
        EventCalendarSet MaterializeEventCalendars(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "EventCalendars" of type <see cref="EventCalendarSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<EventCalendarSet> MaterializeEventCalendarsAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendars" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        [OperationContract]
        IEnumerable<EventCalendar> MaterializeAllEventCalendars(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendars" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<EventCalendar>> MaterializeAllEventCalendarsAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "MemberNotifications" of type <see cref="MemberNotificationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="MemberNotificationSet" />.
        /// </returns>
        [OperationContract]
        MemberNotificationSet MaterializeMemberNotifications(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "MemberNotifications" of type <see cref="MemberNotificationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="MemberNotificationSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<MemberNotificationSet> MaterializeMemberNotificationsAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllMemberNotifications" of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />).
        /// </returns>
        [OperationContract]
        IEnumerable<MemberNotification> MaterializeAllMemberNotifications(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllMemberNotifications" of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<MemberNotification>> MaterializeAllMemberNotificationsAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "Roles" of type <see cref="RoleSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="RoleSet" />.
        /// </returns>
        [OperationContract]
        RoleSet MaterializeRoles(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "Roles" of type <see cref="RoleSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="RoleSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<RoleSet> MaterializeRolesAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllRoles" of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />).
        /// </returns>
        [OperationContract]
        IEnumerable<Role> MaterializeAllRoles(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllRoles" of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Role>> MaterializeAllRolesAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "SignalRHostStates" of type <see cref="SignalRHostStateSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="SignalRHostStateSet" />.
        /// </returns>
        [OperationContract]
        SignalRHostStateSet MaterializeSignalRHostStates(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "SignalRHostStates" of type <see cref="SignalRHostStateSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="SignalRHostStateSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<SignalRHostStateSet> MaterializeSignalRHostStatesAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllSignalRHostStates" of type <see cref="IEnumerable{SignalRHostState}" /> (T = <see cref="SignalRHostState" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{SignalRHostState}" /> (T = <see cref="SignalRHostState" />).
        /// </returns>
        [OperationContract]
        IEnumerable<SignalRHostState> MaterializeAllSignalRHostStates(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllSignalRHostStates" of type <see cref="IEnumerable{SignalRHostState}" /> (T = <see cref="SignalRHostState" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{SignalRHostState}" /> (T = <see cref="SignalRHostState" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<SignalRHostState>> MaterializeAllSignalRHostStatesAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "SignalRMessages" of type <see cref="SignalRMessageSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="SignalRMessageSet" />.
        /// </returns>
        [OperationContract]
        SignalRMessageSet MaterializeSignalRMessages(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "SignalRMessages" of type <see cref="SignalRMessageSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="SignalRMessageSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<SignalRMessageSet> MaterializeSignalRMessagesAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllSignalRMessages" of type <see cref="IEnumerable{SignalRMessage}" /> (T = <see cref="SignalRMessage" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{SignalRMessage}" /> (T = <see cref="SignalRMessage" />).
        /// </returns>
        [OperationContract]
        IEnumerable<SignalRMessage> MaterializeAllSignalRMessages(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllSignalRMessages" of type <see cref="IEnumerable{SignalRMessage}" /> (T = <see cref="SignalRMessage" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{SignalRMessage}" /> (T = <see cref="SignalRMessage" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<SignalRMessage>> MaterializeAllSignalRMessagesAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UserAppMembers" of type <see cref="UserAppMemberSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAppMemberSet" />.
        /// </returns>
        [OperationContract]
        UserAppMemberSet MaterializeUserAppMembers(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserAppMembers" of type <see cref="UserAppMemberSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAppMemberSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserAppMemberSet> MaterializeUserAppMembersAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserAppMembers" of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UserAppMember> MaterializeAllUserAppMembers(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserAppMembers" of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UserAppMember>> MaterializeAllUserAppMembersAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the set of indirectly depending entities "AppUserss" of type <see cref="UserSet" /> of an entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        [OperationContract]
        UserSet MaterializeAppUsers(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of indirectly depending entities "AppUserss" of type <see cref="UserSet" /> of an entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserSet> MaterializeAppUsersAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the collection of indirectly depending entities "AllAppUserss" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        [OperationContract]
        IEnumerable<User> MaterializeAllAppUsers(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of indirectly depending entities "AllAppUserss" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<User>> MaterializeAllAppUsersAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UserDetails" of type <see cref="UserDetailSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserDetailSet" />.
        /// </returns>
        [OperationContract]
        UserDetailSet MaterializeUserDetails(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserDetails" of type <see cref="UserDetailSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserDetailSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserDetailSet> MaterializeUserDetailsAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserDetails" of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UserDetail> MaterializeAllUserDetails(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserDetails" of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UserDetail>> MaterializeAllUserDetailsAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UserGroups" of type <see cref="UserGroupSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserGroupSet" />.
        /// </returns>
        [OperationContract]
        UserGroupSet MaterializeUserGroups(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserGroups" of type <see cref="UserGroupSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserGroupSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserGroupSet> MaterializeUserGroupsAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserGroups" of type <see cref="IEnumerable{UserGroup}" /> (T = <see cref="UserGroup" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserGroup}" /> (T = <see cref="UserGroup" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UserGroup> MaterializeAllUserGroups(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserGroups" of type <see cref="IEnumerable{UserGroup}" /> (T = <see cref="UserGroup" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserGroup}" /> (T = <see cref="UserGroup" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UserGroup>> MaterializeAllUserGroupsAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UserProfiles" of type <see cref="UserProfileSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserProfileSet" />.
        /// </returns>
        [OperationContract]
        UserProfileSet MaterializeUserProfiles(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserProfiles" of type <see cref="UserProfileSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserProfileSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserProfileSet> MaterializeUserProfilesAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserProfiles" of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UserProfile> MaterializeAllUserProfiles(CallContext cntx, Application_ entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserProfiles" of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UserProfile>> MaterializeAllUserProfilesAsync(CallContext cntx, Application_ entity);
#endif

        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="Application_.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Application_.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        [OperationContract]
        Application_ LoadEntityByKey(CallContext cntx, string _ID);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="Application_.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Application_.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<Application_> LoadEntityByKeyAsync(CallContext cntx, string _ID);
#endif

        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="Application_.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Application_.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
        /// It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        [OperationContract]
        Application_ LoadEntityGraphRecurs(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="Application_.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Application_.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
        /// It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<Application_> LoadEntityGraphRecursAsync(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets);
#endif

        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="Application_.Name" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_Name">Intrinsic id <see cref="Application_.Name" />.</param>
        /// <remarks>
        ///  <para>
        ///   If the intrinsic identifiers are well chosen, the returned entity set should contain zero or one item. This could not be the case
        ///   if the system is attached to an existing database whose data were entered without respecting the rules (namely those entities having the
        ///   same set of intrinsic identifiers should appear only once inside the data source) imposed later by the
        ///   system.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   The list of found entities.
        /// </returns>
        [OperationContract]
        List<Application_> LoadEntityByNature(CallContext cntx, string _Name);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="Application_.Name" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_Name">Intrinsic id <see cref="Application_.Name" />.</param>
        /// <remarks>
        ///  <para>
        ///   If the intrinsic identifiers are well chosen, the returned entity set should contain zero or one item. This could not be the case
        ///   if the system is attached to an existing database whose data were entered without respecting the rules (namely those entities having the
        ///   same set of intrinsic identifiers should appear only once inside the data source) imposed later by the
        ///   system.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   The list of found entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<List<Application_>> LoadEntityByNatureAsync(CallContext cntx, string _Name);
#endif

        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        [OperationContract]
        TokenOptions GetNextSorterOps(CallContext cntx, List<QToken> sorters);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<TokenOptions> GetNextSorterOpsAsync(CallContext cntx, List<QToken> sorters);
#endif

        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        [OperationContract]
        TokenOptions GetNextFilterOps(CallContext cntx, QueryExpresion qexpr, string tkstr);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<TokenOptions> GetNextFilterOpsAsync(CallContext cntx, QueryExpresion qexpr, string tkstr);
#endif

    }

}
